##### 一、优势
并发编程之所以让人迷惑是因为有不止一种问题的解决需要使用并发，也有不止一种方法去实现并发，而且他们之间也没有清晰的映射。

使用并发编程来解决的问题可以划分为两类，即“speed”和“designmanageability”。

 

 1. 速度优势：
* 多处理器：多处理器上面并发变成无疑会让程序运行很快。
* 单处理器：如果是单处理器的机器，那么并发编程可能相对于顺序编程没有什么变化。但是，如果其中某一个任务也许会发生阻塞的话，那么即使是单处理器，使用并发编程也会带来很大的好处，这样，某个任务阻塞的时候，其他任务也可以继续运行了。
* 反应灵敏的用户界面：在单处理器上面性能提升最典型的列子就是“事件驱动的编程”，比如创建一个有反应的用户界面，其中有个按钮，如果我们不使用并发编程，那么我们需要在我们编写的每一个代码片段中都要有对用户输入的检测，如果我们使用并发编程，我们只需要重新开启一个线程去监听用户的输入即可。
并发的实现：实现并发的最直接的方式是在操作系统级别，使用进程，进程一种自包含的程序，使用自己的地址空间，操作系统会让进程之间相互隔离，所以进程编程相对容易一些，不需要考虑共享资源的同步等问题。但是在Java中的并发编程，由于线程之间共享相同的memory或者IO等资源，所以Java多线程编程中需要考虑共享资源的同步问题。
进程和Java线程之间的选择：进程的确是一种实现并发的方式，butunfortunately there are generally quantity and overhead limitations toprocesses that prevent their applicability across the concurrency spectrum.


2. 设计上的优势：
* 一般来说，线程使得你能够创建更加松耦合的设计。
* 单处理器：尽管单处理器上面的并发编程在同一时刻处理器仍然只能做一件事情，但是带来一个组织上面的重要优势：就是你的设计(design)会极大地简化。比如仿真。
* 仿真举例：如果没有并发，仿真将变得非常困难。 一般来说仿真涉及到多个交互元素，其中每一个都有“自己的想法”，尽管从程序员的角度来看每一个仿真元素都是被同一个处理器所驱动，但是设计上来看，每一个仿真元素都假装有自己的处理器以及运行独立的任务。

##### 二、风险
1. 安全性问题

主要是多个线程共享数据时可能会产生于期望不相符的结果

 

2. 活跃性问题(liveness)

当某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿、活锁等问题。(死锁、饥饿、活锁可自行百度)

 

3.  性能问题

a. 线程过多时会使得CPU频繁切换，花在调度上时间太多。

b. 多线程环境必须使用同步机制，导致很多编译器想做的优化被抑制。

c. 线程过多还会消耗过多内存。
